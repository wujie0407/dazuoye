<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é£ç­æ¸¡æ²³ - å®æ—¶åé¦ˆç³»ç»Ÿ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            height: 100vh;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 15px;
        }
        
        .header h1 {
            font-size: 2rem;
            margin-bottom: 8px;
            background: linear-gradient(90deg, #667eea, #764ba2, #f093fb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .header p {
            color: #aaa;
            font-size: 0.9rem;
        }
        
        .header a {
            color: #667eea;
            text-decoration: none;
        }
        
        .header a:hover {
            text-decoration: underline;
        }
        
        #canvas-container {
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }
        
        .status-bar {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            color: white;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .status-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.85rem;
        }
        
        .status-item.listening {
            animation: pulse 2s infinite;
        }
        
        .status-item.error {
            background: rgba(255, 100, 100, 0.3);
        }
        
        .status-item.success {
            background: rgba(100, 255, 100, 0.3);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .score-display {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 1.2rem;
            display: none;
        }
        
        .result-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .result-card {
            background: white;
            padding: 40px 60px;
            border-radius: 20px;
            text-align: center;
            animation: popIn 0.5s ease;
        }
        
        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .result-card h2 {
            font-size: 2rem;
            margin-bottom: 15px;
        }
        
        .result-card.success h2 { color: #43e97b; }
        .result-card.struggle h2 { color: #f5af19; }
        .result-card.fail h2 { color: #f5576c; }
        
        .result-card .score {
            font-size: 3rem;
            font-weight: bold;
            margin: 20px 0;
        }
        
        .result-card .details {
            color: #666;
            font-size: 0.9rem;
            margin-top: 15px;
        }
        
        .debug-panel {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #0f0;
            padding: 10px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            max-width: 400px;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .debug-panel .log-entry {
            margin: 2px 0;
        }
        
        .debug-panel .log-error {
            color: #f66;
        }
        
        .debug-panel .log-success {
            color: #6f6;
        }
        
        .test-buttons {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .test-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: transform 0.2s;
        }
        
        .test-btn:hover {
            transform: scale(1.05);
        }
        
        .test-btn.success { background: #43e97b; }
        .test-btn.struggle { background: #f5af19; }
        .test-btn.fail { background: #f5576c; color: white; }
        .test-btn.refresh { background: #667eea; color: white; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸª é£ç­æ¸¡æ²³</h1>
            <p>å®æ—¶åé¦ˆç³»ç»Ÿ | è®¾è®¡å…¥å£ï¼š<a href="https://kite-bindw7rqxvhvvymqv5rqat.streamlit.app/" target="_blank">é£ç­è®¾è®¡ç³»ç»Ÿ</a></p>
        </div>
        
        <div id="canvas-container"></div>
        
        <div class="status-bar">
            <div class="status-item listening" id="status-listen">ğŸ” ç›‘å¬ä¸­...</div>
            <div class="status-item" id="status-connection">è¿æ¥çŠ¶æ€: æ£€æµ‹ä¸­</div>
            <div class="status-item" id="status-count">å·²è¯„ä¼°: 0 ä¸ªè®¾è®¡</div>
            <div class="status-item" id="status-time">æœ€åæ£€æŸ¥: --:--:--</div>
        </div>
    </div>
    
    <div class="test-buttons">
        <button class="test-btn success" onclick="testAnimation(90)">æµ‹è¯•æˆåŠŸ</button>
        <button class="test-btn struggle" onclick="testAnimation(65)">æµ‹è¯•å‹‰å¼º</button>
        <button class="test-btn fail" onclick="testAnimation(30)">æµ‹è¯•å¤±è´¥</button>
        <button class="test-btn refresh" onclick="manualCheck()">æ‰‹åŠ¨æ£€æŸ¥</button>
    </div>
    
    <div class="score-display" id="score-display">
        è¯„åˆ†: <span id="current-score">--</span>/100
    </div>
    
    <div class="result-overlay" id="result-overlay">
        <div class="result-card" id="result-card">
            <h2 id="result-title">æ¸¡æ²³æˆåŠŸï¼</h2>
            <div class="score" id="result-score">85</div>
            <p id="result-message">é£ç­ç¨³å®šé£è¡Œï¼Œé¡ºåˆ©ç©¿è¶Šæ²³æµï¼</p>
            <div class="details" id="result-details"></div>
        </div>
    </div>
    
    <div class="debug-panel" id="debug-panel">
        <div>ğŸ“‹ è°ƒè¯•æ—¥å¿—:</div>
    </div>

    <script>
        // ==================== é…ç½® ====================
        const CONFIG = {
            // ä½¿ç”¨ JSONP æ–¹å¼æˆ–å…¬å¼€è®¿é—®
            BIN_ID: "69531d32ae596e708fb90332",
            API_KEY: "$2a$10$pleOacf0lQu1mvIU//jjfeYPUCb.kiFXX.08qupD/90UYKwHtU8e.",
            CHECK_INTERVAL: 3000,
            ANIMATION_DURATION: 6000,
            SCORE_SUCCESS: 80,
            SCORE_STRUGGLE: 50
        };
        
        // ==================== è°ƒè¯•æ—¥å¿— ====================
        function debugLog(message, type = 'info') {
            const panel = document.getElementById('debug-panel');
            const entry = document.createElement('div');
            entry.className = 'log-entry' + (type === 'error' ? ' log-error' : type === 'success' ? ' log-success' : '');
            const time = new Date().toLocaleTimeString();
            entry.textContent = `[${time}] ${message}`;
            panel.appendChild(entry);
            panel.scrollTop = panel.scrollHeight;
            
            while (panel.children.length > 20) {
                panel.removeChild(panel.children[1]);
            }
            
            console.log(`[${type}] ${message}`);
        }
        
        // ==================== çŠ¶æ€ç®¡ç† ====================
        let processedDesigns = new Set();
        let evaluatedCount = 0;
        let isAnimating = false;
        let connectionOk = false;
        
        // ==================== p5.js åŠ¨ç”» ====================
        let kite;
        let river;
        let particles = [];
        let animationState = 'idle';
        let animationProgress = 0;
        let currentScore = 0;
        let resultType = 'success';
        
        function setup() {
            let canvas = createCanvas(900, 500);
            canvas.parent('canvas-container');
            
            kite = {
                x: 100,
                y: 250,
                angle: 0,
                wobble: 0,
                tail: []
            };
            
            river = {
                y: 350,
                waveOffset: 0
            };
            
            debugLog('p5.js åˆå§‹åŒ–å®Œæˆ', 'success');
            startListening();
        }
        
        function draw() {
            drawSky();
            drawClouds();
            drawRiver();
            drawBank();
            
            if (animationState !== 'idle') {
                updateKite();
            }
            drawKite();
            
            updateParticles();
            drawParticles();
            
            if (animationState === 'idle') {
                drawIdleText();
            }
        }
        
        function drawSky() {
            for (let y = 0; y < height * 0.7; y++) {
                let inter = map(y, 0, height * 0.7, 0, 1);
                let c = lerpColor(color(135, 206, 235), color(176, 224, 230), inter);
                stroke(c);
                line(0, y, width, y);
            }
        }
        
        function drawClouds() {
            fill(255, 255, 255, 200);
            noStroke();
            drawCloud(150, 80, 60);
            drawCloud(400, 50, 80);
            drawCloud(700, 100, 50);
            drawCloud(550, 130, 40);
        }
        
        function drawCloud(x, y, size) {
            ellipse(x, y, size * 1.5, size);
            ellipse(x - size * 0.5, y + size * 0.2, size, size * 0.8);
            ellipse(x + size * 0.5, y + size * 0.2, size * 1.2, size * 0.9);
        }
        
        function drawRiver() {
            river.waveOffset += 0.02;
            
            for (let y = river.y; y < height; y++) {
                let inter = map(y, river.y, height, 0, 1);
                let c = lerpColor(color(64, 164, 223), color(30, 100, 160), inter);
                stroke(c);
                line(0, y, width, y);
            }
            
            noFill();
            stroke(255, 255, 255, 100);
            strokeWeight(2);
            
            for (let i = 0; i < 5; i++) {
                beginShape();
                for (let x = 0; x <= width; x += 20) {
                    let y = river.y + 20 + i * 25 + sin(x * 0.02 + river.waveOffset + i) * 8;
                    vertex(x, y);
                }
                endShape();
            }
            
            strokeWeight(1);
        }
        
        function drawBank() {
            fill(139, 119, 101);
            noStroke();
            rect(0, river.y - 20, 120, height - river.y + 20);
            
            fill(124, 179, 66);
            rect(0, river.y - 40, 120, 30);
            
            fill(139, 119, 101);
            rect(width - 120, river.y - 20, 120, height - river.y + 20);
            
            fill(124, 179, 66);
            rect(width - 120, river.y - 40, 120, 30);
            
            drawGrass(30, river.y - 40);
            drawGrass(70, river.y - 35);
            drawGrass(90, river.y - 38);
            drawGrass(width - 30, river.y - 40);
            drawGrass(width - 70, river.y - 35);
            drawGrass(width - 90, river.y - 38);
        }
        
        function drawGrass(x, y) {
            stroke(76, 139, 59);
            strokeWeight(2);
            for (let i = -2; i <= 2; i++) {
                let angle = PI/2 + i * 0.15 + sin(frameCount * 0.05 + x) * 0.1;
                let len = 15 + (frameCount + x) % 10;
                line(x + i * 3, y, x + i * 3 + cos(angle) * len, y - sin(angle) * len);
            }
            strokeWeight(1);
            noStroke();
        }
        
        function drawKite() {
            push();
            translate(kite.x, kite.y);
            rotate(kite.angle + sin(kite.wobble) * 0.1);
            
            fill(220, 60, 60);
            stroke(139, 0, 0);
            strokeWeight(2);
            
            beginShape();
            vertex(0, -40);
            vertex(30, 0);
            vertex(0, 50);
            vertex(-30, 0);
            endShape(CLOSE);
            
            stroke(101, 67, 33);
            strokeWeight(3);
            line(0, -40, 0, 50);
            line(-30, 0, 30, 0);
            
            noStroke();
            fill(255, 215, 0);
            ellipse(0, 0, 20, 20);
            
            fill(220, 60, 60);
            ellipse(0, 0, 10, 10);
            
            pop();
            
            drawKiteTail();
            drawKiteString();
        }
        
        function drawKiteTail() {
            kite.tail.unshift({x: kite.x, y: kite.y + 50});
            if (kite.tail.length > 20) kite.tail.pop();
            
            noFill();
            stroke(255, 100, 100);
            strokeWeight(3);
            
            beginShape();
            for (let i = 0; i < kite.tail.length; i++) {
                let t = kite.tail[i];
                let wobble = sin(frameCount * 0.1 + i * 0.5) * (5 + i * 0.5);
                vertex(t.x + wobble, t.y + i * 3);
            }
            endShape();
            
            for (let i = 0; i < kite.tail.length; i += 4) {
                if (i < kite.tail.length) {
                    let t = kite.tail[i];
                    let wobble = sin(frameCount * 0.1 + i * 0.5) * (5 + i * 0.5);
                    fill(255, 200, 100);
                    noStroke();
                    ellipse(t.x + wobble, t.y + i * 3, 8, 8);
                }
            }
            
            strokeWeight(1);
        }
        
        function drawKiteString() {
            stroke(100, 100, 100);
            strokeWeight(1);
            
            noFill();
            beginShape();
            vertex(50, height - 50);
            
            let midX = (50 + kite.x) / 2;
            let midY = (height - 50 + kite.y + 50) / 2 + 30;
            quadraticVertex(midX, midY, kite.x, kite.y + 50);
            endShape();
        }
        
        function updateKite() {
            animationProgress += deltaTime;
            let progress = constrain(animationProgress / CONFIG.ANIMATION_DURATION, 0, 1);
            
            let easeProgress = easeInOutCubic(progress);
            
            if (resultType === 'success') {
                kite.x = lerp(100, 800, easeProgress);
                kite.y = lerp(250, 150, easeProgress) + sin(frameCount * 0.05) * 5;
                kite.angle = sin(frameCount * 0.03) * 0.05;
                kite.wobble += 0.1;
                
            } else if (resultType === 'struggle') {
                kite.x = lerp(100, 800, easeProgress);
                kite.y = lerp(250, 200, easeProgress) + sin(frameCount * 0.1) * 30;
                kite.angle = sin(frameCount * 0.08) * 0.3;
                kite.wobble += 0.2;
                
                if (frameCount % 10 === 0) {
                    addParticle(kite.x, kite.y, 'wind');
                }
                
            } else if (resultType === 'fail') {
                if (progress < 0.5) {
                    kite.x = lerp(100, 450, progress * 2);
                    kite.y = lerp(250, 200, progress * 2) + sin(frameCount * 0.15) * 40;
                    kite.angle = sin(frameCount * 0.1) * 0.5;
                } else {
                    let fallProgress = (progress - 0.5) * 2;
                    kite.x = lerp(450, 400, fallProgress);
                    kite.y = lerp(200, river.y + 50, easeInQuad(fallProgress));
                    kite.angle += 0.05;
                    
                    if (frameCount % 5 === 0) {
                        addParticle(kite.x, kite.y, 'fall');
                    }
                }
                kite.wobble += 0.3;
            }
            
            if (progress >= 1) {
                showResult();
            }
        }
        
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        function easeInQuad(t) {
            return t * t;
        }
        
        function addParticle(x, y, type) {
            for (let i = 0; i < 3; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 40,
                    y: y + (Math.random() - 0.5) * 40,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 60,
                    type: type
                });
            }
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        function drawParticles() {
            noStroke();
            for (let p of particles) {
                let alpha = map(p.life, 0, 60, 0, 255);
                
                if (p.type === 'wind') {
                    fill(200, 200, 255, alpha);
                } else if (p.type === 'fall') {
                    fill(255, 100, 100, alpha);
                } else {
                    fill(255, 255, 200, alpha);
                }
                
                ellipse(p.x, p.y, 8, 8);
            }
        }
        
        function drawIdleText() {
            fill(255, 255, 255, 150);
            textAlign(CENTER, CENTER);
            textSize(24);
            text('ç­‰å¾…æ–°è®¾è®¡...', width / 2, height / 2);
            
            let pulse = sin(frameCount * 0.05) * 0.3 + 0.7;
            fill(255, 255, 255, 100 * pulse);
            textSize(16);
            
            let statusText = connectionOk ? 'ç³»ç»Ÿæ­£åœ¨ç›‘å¬ JSONBin' : 'æ­£åœ¨è¿æ¥...';
            text(statusText, width / 2, height / 2 + 40);
        }
        
        // ==================== åŠ¨ç”»æ§åˆ¶ ====================
        function startAnimation(score, designData) {
            if (isAnimating) {
                debugLog('åŠ¨ç”»è¿›è¡Œä¸­ï¼Œè·³è¿‡', 'info');
                return;
            }
            
            isAnimating = true;
            currentScore = score;
            animationProgress = 0;
            
            if (score >= CONFIG.SCORE_SUCCESS) {
                resultType = 'success';
            } else if (score >= CONFIG.SCORE_STRUGGLE) {
                resultType = 'struggle';
            } else {
                resultType = 'fail';
            }
            
            kite.x = 100;
            kite.y = 250;
            kite.angle = 0;
            kite.wobble = 0;
            kite.tail = [];
            particles = [];
            
            document.getElementById('score-display').style.display = 'block';
            document.getElementById('current-score').textContent = score.toFixed(1);
            
            animationState = 'flying';
            
            debugLog(`å¼€å§‹åŠ¨ç”»: åˆ†æ•°=${score.toFixed(1)}, ç»“å±€=${resultType}`, 'success');
        }
        
        function showResult() {
            animationState = 'idle';
            isAnimating = false;
            
            let overlay = document.getElementById('result-overlay');
            let card = document.getElementById('result-card');
            let title = document.getElementById('result-title');
            let score = document.getElementById('result-score');
            let message = document.getElementById('result-message');
            
            card.className = 'result-card ' + resultType;
            
            if (resultType === 'success') {
                title.textContent = 'ğŸ‰ æ¸¡æ²³æˆåŠŸï¼';
                message.textContent = 'é£ç­ç¨³å®šé£è¡Œï¼Œé¡ºåˆ©ç©¿è¶Šæ²³æµï¼';
            } else if (resultType === 'struggle') {
                title.textContent = 'ğŸ˜… å‹‰å¼ºæ¸¡æ²³';
                message.textContent = 'é£ç­æ‘‡æ‘‡æ™ƒæ™ƒï¼ŒæƒŠé™©é€šè¿‡ï¼';
            } else {
                title.textContent = 'ğŸ’¦ æ¸¡æ²³å¤±è´¥';
                message.textContent = 'é£ç­å¤±å»æ§åˆ¶ï¼Œå å…¥æ²³ä¸­...';
            }
            
            score.textContent = currentScore.toFixed(1);
            
            overlay.style.display = 'flex';
            
            setTimeout(() => {
                overlay.style.display = 'none';
                document.getElementById('score-display').style.display = 'none';
                
                kite.x = 100;
                kite.y = 250;
            }, 3000);
        }
        
        // ==================== æµ‹è¯•å‡½æ•° ====================
        function testAnimation(score) {
            debugLog(`æ‰‹åŠ¨æµ‹è¯•: åˆ†æ•°=${score}`, 'info');
            startAnimation(score, {});
        }
        
        function manualCheck() {
            debugLog('æ‰‹åŠ¨è§¦å‘æ£€æŸ¥...', 'info');
            checkForNewDesigns();
        }
        
        // ==================== JSONBin ç›‘å¬ (ä½¿ç”¨ JSONP ä»£ç†) ====================
        
        // æ–¹æ³•1: ä½¿ç”¨ allorigins ä»£ç†ç»•è¿‡ CORS
        async function fetchDesigns() {
            const binUrl = `https://api.jsonbin.io/v3/b/${CONFIG.BIN_ID}/latest`;
            
            // ä½¿ç”¨å…¬å…± CORS ä»£ç†
            const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(binUrl)}`;
            
            debugLog(`é€šè¿‡ä»£ç†è¯·æ±‚...`);
            
            try {
                const response = await fetch(proxyUrl);
                
                if (!response.ok) {
                    throw new Error(`ä»£ç†è¯·æ±‚å¤±è´¥: ${response.status}`);
                }
                
                const proxyData = await response.json();
                
                // allorigins è¿”å›çš„æ•°æ®åœ¨ contents å­—æ®µä¸­
                if (!proxyData.contents) {
                    throw new Error('ä»£ç†è¿”å›æ•°æ®ä¸ºç©º');
                }
                
                const data = JSON.parse(proxyData.contents);
                
                connectionOk = true;
                document.getElementById('status-connection').textContent = 'è¿æ¥çŠ¶æ€: âœ… æ­£å¸¸';
                document.getElementById('status-connection').className = 'status-item success';
                
                const designs = data.record?.designs || [];
                debugLog(`è·å–åˆ° ${designs.length} ä¸ªè®¾è®¡`, 'success');
                
                return designs;
                
            } catch (error) {
                // å°è¯•å¤‡ç”¨ä»£ç†
                return await fetchDesignsBackup();
            }
        }
        
        // å¤‡ç”¨æ–¹æ³•: ä½¿ç”¨å¦ä¸€ä¸ª CORS ä»£ç†
        async function fetchDesignsBackup() {
            const binUrl = `https://api.jsonbin.io/v3/b/${CONFIG.BIN_ID}/latest`;
            const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(binUrl)}`;
            
            debugLog(`å°è¯•å¤‡ç”¨ä»£ç†...`);
            
            try {
                const response = await fetch(proxyUrl, {
                    headers: {
                        'X-Master-Key': CONFIG.API_KEY
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                
                connectionOk = true;
                document.getElementById('status-connection').textContent = 'è¿æ¥çŠ¶æ€: âœ… æ­£å¸¸';
                document.getElementById('status-connection').className = 'status-item success';
                
                const designs = data.record?.designs || [];
                debugLog(`è·å–åˆ° ${designs.length} ä¸ªè®¾è®¡`, 'success');
                
                return designs;
                
            } catch (error) {
                connectionOk = false;
                document.getElementById('status-connection').textContent = 'è¿æ¥çŠ¶æ€: âŒ å¤±è´¥';
                document.getElementById('status-connection').className = 'status-item error';
                
                debugLog(`é”™è¯¯: ${error.message}`, 'error');
                return null;
            }
        }
        
        function calculateScore(design) {
            // ä¸ ai_scorer.py çš„ _calculate_comprehensive_score ä¿æŒä¸€è‡´
            const materials = design.materials || {};
            const drawing = design.drawing || {};
            
            // ææ–™å±æ€§ï¼ˆä¸ kite_calculator.py ä¸€è‡´ï¼‰
            const MATERIAL_PROPS = {
                'éª¨æ¶ææ–™': {
                    'ç«¹å­':   { strength: 80,  density: 0.6, cost: 1.0 },
                    'é“åˆé‡‘': { strength: 150, density: 2.7, cost: 3.5 },
                    'ç¢³çº¤ç»´': { strength: 200, density: 1.6, cost: 8.0 }
                },
                'é£ç­é¢æ–™': {
                    'ä¸ç»¸':   { wind_resistance: 70, weight_sqm: 60, cost: 2.0 },
                    'å°¼é¾™':   { wind_resistance: 95, weight_sqm: 85, cost: 1.5 },
                    'Mylarè†œ': { wind_resistance: 85, weight_sqm: 50, cost: 3.0 }
                },
                'ç»³ç´¢ææ–™': {
                    'éº»ç»³':   { tensile: 500,  cost: 0.5 },
                    'é’¢ç´¢':   { tensile: 2000, cost: 2.0 },
                    'å‡¯å¤«æ‹‰': { tensile: 3000, cost: 5.0 }
                }
            };
            
            // 1. è®¡ç®—æ€§èƒ½åˆ† (40%)
            let strengthIndex = 0;
            let windResistance = 0;
            let flightStability = 0;
            
            // éª¨æ¶å¼ºåº¦
            const frameMats = materials['éª¨æ¶ææ–™'] || [];
            if (frameMats.length > 0) {
                let totalStrength = 0;
                for (let m of frameMats) {
                    if (MATERIAL_PROPS['éª¨æ¶ææ–™'][m]) {
                        totalStrength += MATERIAL_PROPS['éª¨æ¶ææ–™'][m].strength;
                    }
                }
                strengthIndex = totalStrength / frameMats.length;
            }
            
            // é¢æ–™æŠ—é£
            const surfaceMats = materials['é£ç­é¢æ–™'] || [];
            if (surfaceMats.length > 0) {
                let totalWind = 0;
                for (let m of surfaceMats) {
                    if (MATERIAL_PROPS['é£ç­é¢æ–™'][m]) {
                        totalWind += MATERIAL_PROPS['é£ç­é¢æ–™'][m].wind_resistance;
                    }
                }
                windResistance = totalWind / surfaceMats.length;
            }
            
            // é£è¡Œç¨³å®šæ€§ï¼ˆåŸºäºç»˜å›¾å¤æ‚åº¦å’Œææ–™ç»„åˆï¼‰
            const objectCount = drawing.object_count || 0;
            const hasFrame = frameMats.length > 0;
            const hasSurface = surfaceMats.length > 0;
            
            if (hasFrame && hasSurface) {
                flightStability = Math.min(50 + objectCount * 5, 80);
            } else if (hasFrame || hasSurface) {
                flightStability = Math.min(30 + objectCount * 3, 50);
            } else {
                flightStability = Math.min(objectCount * 2, 30);
            }
            
            const performanceScore = (
                flightStability * 0.5 +
                strengthIndex * 0.3 +
                windResistance * 0.2
            );
            
            // 2. è®¡ç®—å¯è¡Œæ€§åˆ† (30%)
            let feasibilityScore = 40; // é»˜è®¤ä½åˆ†
            
            // åŸºäºææ–™å®Œæ•´åº¦
            const stringMats = materials['ç»³ç´¢ææ–™'] || [];
            const materialsComplete = frameMats.length > 0 && surfaceMats.length > 0 && stringMats.length > 0;
            const materialsPartial = frameMats.length > 0 || surfaceMats.length > 0;
            
            if (materialsComplete && objectCount > 0) {
                feasibilityScore = 100;
            } else if (materialsComplete) {
                feasibilityScore = 80;
            } else if (materialsPartial && objectCount > 0) {
                feasibilityScore = 60;
            } else if (materialsPartial) {
                feasibilityScore = 50;
            }
            
            // 3. è®¡ç®—æˆæœ¬åˆ† (20%)
            let totalCost = 0;
            for (let category in materials) {
                const items = materials[category] || [];
                for (let item of items) {
                    if (MATERIAL_PROPS[category] && MATERIAL_PROPS[category][item]) {
                        totalCost += MATERIAL_PROPS[category][item].cost * 10;
                    }
                }
            }
            
            let costScore;
            if (totalCost < 50) {
                costScore = 100;
            } else if (totalCost < 100) {
                costScore = 80;
            } else if (totalCost < 150) {
                costScore = 60;
            } else {
                costScore = 30;
            }
            
            // 4. è®¡ç®—åˆ›æ–°åˆ† (10%)
            const materialsCount = frameMats.length + surfaceMats.length + stringMats.length;
            const innovationScore = Math.min(materialsCount * 20, 100);
            
            // ç»¼åˆè¯„åˆ†
            const finalScore = (
                performanceScore * 0.40 +
                feasibilityScore * 0.30 +
                costScore * 0.20 +
                innovationScore * 0.10
            );
            
            debugLog(`è¯„åˆ†è¯¦æƒ…: æ€§èƒ½=${performanceScore.toFixed(1)}, å¯è¡Œ=${feasibilityScore}, æˆæœ¬=${costScore}, åˆ›æ–°=${innovationScore}`);
            
            return Math.round(finalScore * 10) / 10;
        }
        
        async function checkForNewDesigns() {
            if (isAnimating) {
                debugLog('åŠ¨ç”»ä¸­ï¼Œè·³è¿‡æ£€æŸ¥');
                return;
            }
            
            document.getElementById('status-time').textContent = `æœ€åæ£€æŸ¥: ${new Date().toLocaleTimeString()}`;
            
            const designs = await fetchDesigns();
            if (!designs) return;
            
            for (let design of designs) {
                const designId = design.design_id || design.created_at;
                
                if (!processedDesigns.has(designId)) {
                    processedDesigns.add(designId);
                    evaluatedCount++;
                    
                    document.getElementById('status-count').textContent = `å·²è¯„ä¼°: ${evaluatedCount} ä¸ªè®¾è®¡`;
                    
                    const score = calculateScore(design);
                    debugLog(`æ–°è®¾è®¡: ${designId.substring(0,15)}..., åˆ†æ•°: ${score.toFixed(1)}`, 'success');
                    
                    startAnimation(score, design);
                    break;
                }
            }
        }
        
        function startListening() {
            debugLog('å¼€å§‹ç›‘å¬ JSONBin (é€šè¿‡ CORS ä»£ç†)...');
            
            fetchDesigns().then(designs => {
                if (designs) {
                    for (let design of designs) {
                        const designId = design.design_id || design.created_at;
                        processedDesigns.add(designId);
                    }
                    debugLog(`å·²æ ‡è®° ${processedDesigns.size} ä¸ªç°æœ‰è®¾è®¡`, 'success');
                }
            });
            
            setInterval(checkForNewDesigns, CONFIG.CHECK_INTERVAL);
        }
    </script>
</body>
</html>
