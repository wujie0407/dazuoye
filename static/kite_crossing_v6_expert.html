<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é£ç­æ¸¡æ²³</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700;900&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Noto Sans SC', sans-serif;
            background: #453d7c;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        
        #canvas-container {
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 0 0 3px #8dc99f, 0 0 0 6px #704da8, 0 25px 80px rgba(69, 61, 124, 0.6);
            position: relative;
        }
        
        /* çŠ¶æ€æ  */
        .status-bar {
            position: fixed;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 10;
        }
        
        .status-item {
            background: #704da8;
            color: #c2c0e7;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            border: 2px solid #8dc99f;
        }
        
        .status-item.listening { animation: pulse 1.5s infinite; }
        .status-item.success { background: #8dc99f; color: #453d7c; }
        .status-item.error { border-color: #ff6b6b; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        /* æµ‹è¯•æŒ‰é’® */
        .test-buttons {
            position: fixed;
            top: 15px;
            left: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10;
        }
        
        .test-btn {
            padding: 8px 14px;
            border: 2px solid #8dc99f;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 700;
            background: #704da8;
            color: #c2c0e7;
            transition: all 0.2s;
        }
        
        .test-btn:hover {
            background: #8dc99f;
            color: #453d7c;
        }
        
        /* ä¸“å®¶ç‚¹è¯„é®ç½©å±‚ */
        .expert-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(69, 61, 124, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
            flex-direction: column;
            padding: 30px;
        }
        
        /* é£ç­å±•ç¤ºåŒº */
        .kite-display {
            display: flex;
            align-items: center;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .kite-icon {
            width: 80px;
            height: 100px;
            position: relative;
        }
        
        .kite-icon svg {
            width: 100%;
            height: 100%;
        }
        
        .kite-info {
            color: #c2c0e7;
        }
        
        .kite-info h2 {
            color: #8dc99f;
            font-size: 1.5rem;
            margin-bottom: 8px;
        }
        
        .kite-info p {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .crossing-score {
            background: #704da8;
            padding: 8px 20px;
            border-radius: 20px;
            margin-top: 10px;
            display: inline-block;
        }
        
        .crossing-score span {
            color: #8dc99f;
            font-weight: 900;
            font-size: 1.2rem;
        }
        
        /* ä¸“å®¶é¢æ¿ */
        .experts-panel {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .expert-card {
            width: 120px;
            text-align: center;
            opacity: 0.3;
            transition: all 0.5s ease;
            transform: scale(0.9);
        }
        
        .expert-card.active {
            opacity: 1;
            transform: scale(1);
        }
        
        .expert-card.done {
            opacity: 0.7;
            transform: scale(0.95);
        }
        
        .expert-avatar {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            margin: 0 auto 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            border: 3px solid #704da8;
            transition: all 0.3s;
        }
        
        .expert-card.active .expert-avatar {
            border-color: #8dc99f;
            box-shadow: 0 0 20px rgba(141, 201, 159, 0.5);
        }
        
        .expert-avatar.physicist { background: linear-gradient(135deg, #667eea, #764ba2); }
        .expert-avatar.meteorologist { background: linear-gradient(135deg, #11998e, #38ef7d); }
        .expert-avatar.lawyer { background: linear-gradient(135deg, #eb3349, #f45c43); }
        .expert-avatar.investor { background: linear-gradient(135deg, #f2994a, #f2c94c); }
        
        .expert-name {
            color: #c2c0e7;
            font-size: 0.85rem;
            margin-bottom: 5px;
        }
        
        .expert-score {
            font-size: 1.8rem;
            font-weight: 900;
            color: #8dc99f;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        .expert-card.done .expert-score,
        .expert-card.active .expert-score {
            opacity: 1;
        }
        
        /* å‘è¨€åŒº */
        .speech-area {
            background: #352d5c;
            border-radius: 15px;
            padding: 25px 35px;
            max-width: 700px;
            min-height: 120px;
            position: relative;
        }
        
        .speech-area::before {
            content: '"';
            position: absolute;
            top: 10px;
            left: 15px;
            font-size: 3rem;
            color: #704da8;
            font-family: serif;
        }
        
        .speech-content {
            color: #e8e6f5;
            font-size: 1.05rem;
            line-height: 1.8;
            min-height: 60px;
        }
        
        .speech-loading {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #8dc99f;
        }
        
        .speech-loading .dots {
            display: flex;
            gap: 4px;
        }
        
        .speech-loading .dot {
            width: 8px;
            height: 8px;
            background: #8dc99f;
            border-radius: 50%;
            animation: dotPulse 1.4s infinite;
        }
        
        .speech-loading .dot:nth-child(2) { animation-delay: 0.2s; }
        .speech-loading .dot:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes dotPulse {
            0%, 100% { opacity: 0.3; transform: scale(0.8); }
            50% { opacity: 1; transform: scale(1); }
        }
        
        /* ç»¼åˆè¯„åˆ† */
        .final-score-area {
            margin-top: 25px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        .final-score-area.show {
            opacity: 1;
        }
        
        .final-score-label {
            color: #c2c0e7;
            font-size: 0.9rem;
            margin-bottom: 5px;
        }
        
        .final-score-value {
            font-size: 3rem;
            font-weight: 900;
            color: #8dc99f;
            text-shadow: 0 0 30px rgba(141, 201, 159, 0.5);
        }
        
        .final-score-bar {
            width: 300px;
            height: 8px;
            background: #453d7c;
            border-radius: 4px;
            margin: 15px auto;
            overflow: hidden;
        }
        
        .final-score-fill {
            height: 100%;
            background: linear-gradient(90deg, #704da8, #8dc99f);
            border-radius: 4px;
            width: 0%;
            transition: width 1s ease;
        }
        
        .close-btn {
            margin-top: 20px;
            padding: 12px 40px;
            background: #8dc99f;
            color: #453d7c;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            opacity: 0;
            transition: all 0.3s;
        }
        
        .close-btn.show {
            opacity: 1;
        }
        
        .close-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(141, 201, 159, 0.4);
        }
        
        /* è°ƒè¯•é¢æ¿ */
        .debug-panel {
            position: fixed;
            bottom: 60px;
            left: 10px;
            background: rgba(69, 61, 124, 0.95);
            border: 2px solid #704da8;
            color: #8dc99f;
            padding: 8px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 10px;
            max-width: 300px;
            max-height: 100px;
            overflow-y: auto;
            z-index: 10;
        }
        
        .debug-panel .log-error { color: #ff8a8a; }
        .debug-panel .log-success { color: #8dc99f; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="status-bar">
        <div class="status-item listening" id="status-listen">ğŸ” ç›‘å¬ä¸­</div>
        <div class="status-item" id="status-connection">è¿æ¥ä¸­...</div>
        <div class="status-item" id="status-count">å·²è¯„ä¼°: 0</div>
        <div class="status-item" id="status-time">--:--:--</div>
    </div>
    
    <div class="test-buttons">
        <button class="test-btn" onclick="testAnimation(90)">âœ“ æˆåŠŸ</button>
        <button class="test-btn" onclick="testAnimation(65)">~ å‹‰å¼º</button>
        <button class="test-btn" onclick="testAnimation(30)">âœ— å¤±è´¥</button>
        <button class="test-btn" onclick="manualCheck()">âŸ³ åˆ·æ–°</button>
    </div>
    
    <!-- ä¸“å®¶ç‚¹è¯„é®ç½© -->
    <div class="expert-overlay" id="expert-overlay">
        <!-- é£ç­ä¿¡æ¯ -->
        <div class="kite-display">
            <div class="kite-icon">
                <svg viewBox="0 0 80 100">
                    <polygon points="40,5 75,40 40,95 5,40" fill="#8dc99f" stroke="#453d7c" stroke-width="3"/>
                    <line x1="40" y1="5" x2="40" y2="95" stroke="#453d7c" stroke-width="2"/>
                    <line x1="5" y1="40" x2="75" y2="40" stroke="#453d7c" stroke-width="2"/>
                    <polygon points="40,25 50,40 40,60 30,40" fill="#704da8"/>
                </svg>
            </div>
            <div class="kite-info">
                <h2>ğŸª é£ç­è®¾è®¡è¯„å®¡</h2>
                <p id="materials-display">ææ–™: åŠ è½½ä¸­...</p>
                <div class="crossing-score">
                    æ¸¡æ²³å¾—åˆ†: <span id="crossing-score-value">--</span>
                </div>
            </div>
        </div>
        
        <!-- å››ä½ä¸“å®¶ -->
        <div class="experts-panel">
            <div class="expert-card" id="expert-0">
                <div class="expert-avatar physicist">ğŸ”¬</div>
                <div class="expert-name">ç‰©ç†å­¦å®¶</div>
                <div class="expert-score" id="score-0">--</div>
            </div>
            <div class="expert-card" id="expert-1">
                <div class="expert-avatar meteorologist">ğŸŒ¤ï¸</div>
                <div class="expert-name">æ°”è±¡å­¦å®¶</div>
                <div class="expert-score" id="score-1">--</div>
            </div>
            <div class="expert-card" id="expert-2">
                <div class="expert-avatar lawyer">âš–ï¸</div>
                <div class="expert-name">æ³•å¾‹å­¦å®¶</div>
                <div class="expert-score" id="score-2">--</div>
            </div>
            <div class="expert-card" id="expert-3">
                <div class="expert-avatar investor">ğŸ’°</div>
                <div class="expert-name">æŠ•èµ„äºº</div>
                <div class="expert-score" id="score-3">--</div>
            </div>
        </div>
        
        <!-- å‘è¨€åŒº -->
        <div class="speech-area">
            <div class="speech-content" id="speech-content">
                <div class="speech-loading">
                    <span>ä¸“å®¶æ­£åœ¨åˆ†æ</span>
                    <div class="dots">
                        <div class="dot"></div>
                        <div class="dot"></div>
                        <div class="dot"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- ç»¼åˆè¯„åˆ† -->
        <div class="final-score-area" id="final-score-area">
            <div class="final-score-label">ä¸“å®¶ç»¼åˆè¯„åˆ†</div>
            <div class="final-score-value" id="final-score-value">--</div>
            <div class="final-score-bar">
                <div class="final-score-fill" id="final-score-fill"></div>
            </div>
        </div>
        
        <button class="close-btn" id="close-btn" onclick="closeExpertPanel()">å®Œæˆè¯„å®¡</button>
    </div>
    
    <div class="debug-panel" id="debug-panel">
        <div>æ—¥å¿—:</div>
    </div>

    <script>
        // ==================== é…ç½® ====================
        const CONFIG = {
            BIN_ID: "695796c6d0ea881f404f4611",
            JSONBIN_API_KEY: "$2a$10$pleOacf0lQu1mvIU//jjfeYPUCb.kiFXX.08qupD/90UYKwHtU8e.",
            ZHIPU_API_KEY: "b91a0c07fd0640f488491d6bd0fa4e7f.z5j8U7iiyrWkO5sc",
            ZHIPU_API_URL: "https://open.bigmodel.cn/api/paas/v4/chat/completions",
            CHECK_INTERVAL: 3000,
            ANIMATION_DURATION: 5000,
            SCORE_SUCCESS: 80,
            SCORE_STRUGGLE: 50
        };
        
        // ==================== ä¸“å®¶é…ç½® ====================
        const EXPERTS = [
            {
                id: 'physicist',
                name: 'ç‰©ç†å­¦å®¶',
                emoji: 'ğŸ”¬',
                systemPrompt: `ä½ æ˜¯ä¸€ä½ä¸¥è°¨çš„ç‰©ç†å­¦å®¶ï¼Œä¸“ç²¾ç©ºæ°”åŠ¨åŠ›å­¦å’Œç»“æ„åŠ›å­¦ã€‚
è¯·ç”¨50-80å­—è¯„ä»·è¿™ä¸ªé£ç­è®¾è®¡ï¼Œä»ä»¥ä¸‹è§’åº¦ï¼š
- å‡åŠ›ä¸é˜»åŠ›æ¯”
- ç»“æ„å¼ºåº¦ä¸é‡å¿ƒå¹³è¡¡
- ææ–™çš„ç‰©ç†ç‰¹æ€§

è¯„ä»·è¦ä¸“ä¸šä½†æ˜“æ‡‚ï¼Œæœ€åç»™å‡º0-100çš„è¯„åˆ†ã€‚
å›å¤æ ¼å¼ï¼š[è¯„è¯­å†…å®¹]|[åˆ†æ•°]
ä¾‹å¦‚ï¼šè¿™ä¸ªè®¾è®¡çš„å‡åŠ›ç³»æ•°è¾ƒä¸ºç†æƒ³...|85`
            },
            {
                id: 'meteorologist', 
                name: 'æ°”è±¡å­¦å®¶',
                emoji: 'ğŸŒ¤ï¸',
                systemPrompt: `ä½ æ˜¯ä¸€ä½ç»éªŒä¸°å¯Œçš„æ°”è±¡å­¦å®¶ï¼Œç†Ÿæ‚‰å„ç§å¤©æ°”æ¡ä»¶å¯¹é£è¡Œçš„å½±å“ã€‚
è¯·ç”¨50-80å­—è¯„ä»·è¿™ä¸ªé£ç­è®¾è®¡ï¼Œä»ä»¥ä¸‹è§’åº¦ï¼š
- é€‚åº”çš„é£é€ŸèŒƒå›´
- æ°”æµç¨³å®šæ€§
- ä¸åŒå¤©æ°”ä¸‹çš„è¡¨ç°

è¯„ä»·è¦ä¸“ä¸šä½†æ˜“æ‡‚ï¼Œæœ€åç»™å‡º0-100çš„è¯„åˆ†ã€‚
å›å¤æ ¼å¼ï¼š[è¯„è¯­å†…å®¹]|[åˆ†æ•°]
ä¾‹å¦‚ï¼šä»æ°”è±¡å­¦è§’åº¦ï¼Œè¯¥é£ç­é€‚åˆåœ¨...|78`
            },
            {
                id: 'lawyer',
                name: 'æ³•å¾‹å­¦å®¶', 
                emoji: 'âš–ï¸',
                systemPrompt: `ä½ æ˜¯ä¸€ä½å…³æ³¨å…¬å…±å®‰å…¨çš„æ³•å¾‹ä¸“å®¶ï¼Œç†Ÿæ‚‰é£è¡Œå™¨ç›¸å…³æ³•è§„ã€‚
è¯·ç”¨50-80å­—è¯„ä»·è¿™ä¸ªé£ç­è®¾è®¡ï¼Œä»ä»¥ä¸‹è§’åº¦ï¼š
- æ˜¯å¦ç¬¦åˆå®‰å…¨è§„èŒƒ
- æ½œåœ¨çš„å®‰å…¨é£é™©
- ä½¿ç”¨åœºæ™¯çš„åˆè§„æ€§

è¯„ä»·è¦ä¸“ä¸šä½†æ˜“æ‡‚ï¼Œæœ€åç»™å‡º0-100çš„è¯„åˆ†ã€‚
å›å¤æ ¼å¼ï¼š[è¯„è¯­å†…å®¹]|[åˆ†æ•°]
ä¾‹å¦‚ï¼šä»æ³•å¾‹åˆè§„è§’åº¦ï¼Œè¯¥è®¾è®¡...|82`
            },
            {
                id: 'investor',
                name: 'æŠ•èµ„äºº',
                emoji: 'ğŸ’°', 
                systemPrompt: `ä½ æ˜¯ä¸€ä½ç²¾æ˜çš„æŠ•èµ„äººï¼Œå…³æ³¨äº§å“çš„å•†ä¸šä»·å€¼å’Œå¸‚åœºæ½œåŠ›ã€‚
è¯·ç”¨50-80å­—è¯„ä»·è¿™ä¸ªé£ç­è®¾è®¡ï¼Œä»ä»¥ä¸‹è§’åº¦ï¼š
- ææ–™æˆæœ¬æ§åˆ¶
- å¸‚åœºå¸å¼•åŠ›
- é‡äº§å¯è¡Œæ€§

è¯„ä»·è¦ä¸“ä¸šä½†æ˜“æ‡‚ï¼Œæœ€åç»™å‡º0-100çš„è¯„åˆ†ã€‚
å›å¤æ ¼å¼ï¼š[è¯„è¯­å†…å®¹]|[åˆ†æ•°]
ä¾‹å¦‚ï¼šä»å•†ä¸šè§’åº¦è¯„ä¼°ï¼Œè¿™æ¬¾é£ç­...|75`
            }
        ];
        
        // ==================== é¢œè‰²é…ç½® ====================
        const COLORS = {
            deepPurple: '#453d7c',
            purple: '#704da8',
            lavender: '#c2c0e7',
            mint: '#8dc99f',
            skyLight: '#e8e6f5',
            skyMid: '#b8b4d9',
            mountainFar: '#704da8',
            mountainMid: '#9080c0',
            mountainNear: '#b8b4d9',
            riverMain: '#8dc99f',
            riverLight: '#a8dbb5',
            riverDark: '#6db585',
            bankTop: '#8dc99f',
            bankSide: '#704da8',
            kiteMain: '#8dc99f',
            kiteAccent: '#704da8',
            kiteFrame: '#453d7c',
            white: '#ffffff'
        };
        
        // ==================== çŠ¶æ€å˜é‡ ====================
        let processedDesigns = new Set();
        let evaluatedCount = 0;
        let isAnimating = false;
        let connectionOk = false;
        let currentDesignData = null;
        let crossingScore = 0;
        
        // p5.js å˜é‡
        let kite, river, particles = [];
        let animationState = 'idle';
        let animationProgress = 0;
        let currentScore = 0;
        let resultType = 'success';
        let clouds = [];
        
        // ==================== è°ƒè¯•æ—¥å¿— ====================
        function debugLog(msg, type = 'info') {
            const panel = document.getElementById('debug-panel');
            const entry = document.createElement('div');
            entry.className = type === 'error' ? 'log-error' : type === 'success' ? 'log-success' : '';
            entry.textContent = `${new Date().toLocaleTimeString().slice(0,5)} ${msg}`;
            panel.appendChild(entry);
            panel.scrollTop = panel.scrollHeight;
            while (panel.children.length > 12) panel.removeChild(panel.children[1]);
            console.log(`[${type}] ${msg}`);
        }
        
        // ==================== æ™ºè°± API è°ƒç”¨ ====================
        async function callZhipuAPI(systemPrompt, userMessage) {
            try {
                const response = await fetch(CONFIG.ZHIPU_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${CONFIG.ZHIPU_API_KEY}`
                    },
                    body: JSON.stringify({
                        model: 'glm-4-flash',
                        messages: [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: userMessage }
                        ],
                        max_tokens: 200,
                        temperature: 0.7
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API è¯·æ±‚å¤±è´¥: ${response.status}`);
                }
                
                const data = await response.json();
                return data.choices[0].message.content;
                
            } catch (error) {
                debugLog(`æ™ºè°±APIé”™è¯¯: ${error.message}`, 'error');
                return null;
            }
        }
        
        // ==================== ä¸“å®¶ç‚¹è¯„ç³»ç»Ÿ ====================
        function buildDesignDescription(design) {
            const materials = design?.materials || {};
            const frame = materials['éª¨æ¶ææ–™']?.join('ã€') || 'æœªé€‰æ‹©';
            const surface = materials['é£ç­é¢æ–™']?.join('ã€') || 'æœªé€‰æ‹©';
            const string = materials['ç»³ç´¢ææ–™']?.join('ã€') || 'æœªé€‰æ‹©';
            
            return `é£ç­è®¾è®¡ä¿¡æ¯ï¼š
- éª¨æ¶ææ–™ï¼š${frame}
- é¢æ–™ææ–™ï¼š${surface}  
- ç»³ç´¢ææ–™ï¼š${string}
- æ¸¡æ²³æµ‹è¯•å¾—åˆ†ï¼š${crossingScore}åˆ†

è¯·æ ¹æ®ä»¥ä¸Šä¿¡æ¯ï¼Œä»ä½ çš„ä¸“ä¸šè§’åº¦è¿›è¡Œè¯„ä»·å’Œæ‰“åˆ†ã€‚`;
        }
        
        function parseExpertResponse(response) {
            if (!response) {
                return { comment: 'è¯„ä¼°ç³»ç»Ÿæš‚æ—¶æ— æ³•è¿æ¥ï¼Œè¯·ç¨åé‡è¯•ã€‚', score: 60 };
            }
            
            // å°è¯•è§£æ "è¯„è¯­|åˆ†æ•°" æ ¼å¼
            const parts = response.split('|');
            if (parts.length >= 2) {
                const comment = parts[0].trim();
                const scoreMatch = parts[1].match(/\d+/);
                const score = scoreMatch ? parseInt(scoreMatch[0]) : 70;
                return { comment, score: Math.min(100, Math.max(0, score)) };
            }
            
            // å°è¯•ä»æ–‡æœ¬ä¸­æå–åˆ†æ•°
            const scoreMatch = response.match(/(\d{1,3})\s*åˆ†/);
            const score = scoreMatch ? parseInt(scoreMatch[1]) : 70;
            
            return { comment: response.slice(0, 150), score: Math.min(100, Math.max(0, score)) };
        }
        
        async function startExpertReview() {
            const overlay = document.getElementById('expert-overlay');
            overlay.style.display = 'flex';
            
            // æ˜¾ç¤ºææ–™ä¿¡æ¯
            const materials = currentDesignData?.materials || {};
            const materialText = [
                materials['éª¨æ¶ææ–™']?.join('ã€'),
                materials['é£ç­é¢æ–™']?.join('ã€'),
                materials['ç»³ç´¢ææ–™']?.join('ã€')
            ].filter(Boolean).join(' | ') || 'æœªé€‰æ‹©ææ–™';
            
            document.getElementById('materials-display').textContent = `ææ–™: ${materialText}`;
            document.getElementById('crossing-score-value').textContent = crossingScore.toFixed(1);
            
            // é‡ç½®ä¸“å®¶å¡ç‰‡
            EXPERTS.forEach((_, i) => {
                document.getElementById(`expert-${i}`).className = 'expert-card';
                document.getElementById(`score-${i}`).textContent = '--';
            });
            
            document.getElementById('final-score-area').classList.remove('show');
            document.getElementById('close-btn').classList.remove('show');
            document.getElementById('final-score-fill').style.width = '0%';
            
            const designDesc = buildDesignDescription(currentDesignData);
            const expertScores = [];
            
            // ä¾æ¬¡è°ƒç”¨æ¯ä½ä¸“å®¶
            for (let i = 0; i < EXPERTS.length; i++) {
                const expert = EXPERTS[i];
                const card = document.getElementById(`expert-${i}`);
                const scoreEl = document.getElementById(`score-${i}`);
                const speechEl = document.getElementById('speech-content');
                
                // æ¿€æ´»å½“å‰ä¸“å®¶
                card.classList.add('active');
                
                // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
                speechEl.innerHTML = `
                    <div class="speech-loading">
                        <span>${expert.emoji} ${expert.name}æ­£åœ¨åˆ†æ</span>
                        <div class="dots">
                            <div class="dot"></div>
                            <div class="dot"></div>
                            <div class="dot"></div>
                        </div>
                    </div>
                `;
                
                debugLog(`è¯·æ±‚ ${expert.name} è¯„ä»·...`);
                
                // è°ƒç”¨ API
                const response = await callZhipuAPI(expert.systemPrompt, designDesc);
                const { comment, score } = parseExpertResponse(response);
                
                expertScores.push(score);
                
                // æ˜¾ç¤ºè¯„åˆ†
                scoreEl.textContent = score;
                
                // æ‰“å­—æœºæ•ˆæœæ˜¾ç¤ºè¯„è¯­
                await typewriterEffect(speechEl, `${expert.emoji} ${expert.name}ï¼š${comment}`);
                
                // æ ‡è®°å®Œæˆ
                card.classList.remove('active');
                card.classList.add('done');
                
                debugLog(`${expert.name}: ${score}åˆ†`, 'success');
                
                // ç­‰å¾…ä¸€ä¸‹å†è¿›è¡Œä¸‹ä¸€ä½
                await sleep(1500);
            }
            
            // è®¡ç®—ç»¼åˆè¯„åˆ†ï¼ˆä¸“å®¶å¹³å‡åˆ† * 0.5 + æ¸¡æ²³åˆ† * 0.5ï¼‰
            const avgExpertScore = expertScores.reduce((a, b) => a + b, 0) / expertScores.length;
            const finalScore = (avgExpertScore * 0.5 + crossingScore * 0.5).toFixed(1);
            
            // æ˜¾ç¤ºæœ€ç»ˆè¯„åˆ†
            document.getElementById('final-score-value').textContent = finalScore;
            document.getElementById('final-score-area').classList.add('show');
            
            await sleep(500);
            document.getElementById('final-score-fill').style.width = `${finalScore}%`;
            
            document.getElementById('speech-content').innerHTML = `
                <div style="text-align: center; color: #8dc99f;">
                    âœ¨ è¯„å®¡å®Œæˆï¼ç»¼åˆè€ƒè™‘æ¸¡æ²³è¡¨ç°ä¸ä¸“å®¶æ„è§ï¼Œæ‚¨çš„é£ç­è®¾è®¡è·å¾—äº† <strong>${finalScore}</strong> åˆ†çš„ç»¼åˆè¯„ä»·ã€‚
                </div>
            `;
            
            await sleep(1000);
            document.getElementById('close-btn').classList.add('show');
        }
        
        async function typewriterEffect(element, text, speed = 30) {
            element.innerHTML = '';
            for (let i = 0; i < text.length; i++) {
                element.innerHTML += text[i];
                await sleep(speed);
            }
        }
        
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        function closeExpertPanel() {
            document.getElementById('expert-overlay').style.display = 'none';
            kite.x = 80;
            kite.y = 180;
        }
        
        // ==================== p5.js åŠ¨ç”»éƒ¨åˆ† ====================
        function setup() {
            let canvas = createCanvas(960, 540);
            canvas.parent('canvas-container');
            
            kite = { x: 80, y: 180, angle: 0, wobble: 0, tail: [] };
            river = { y: 360, wave: 0 };
            
            clouds = [
                { x: 80, y: 50, s: 45 },
                { x: 250, y: 35, s: 60 },
                { x: 450, y: 55, s: 50 },
                { x: 650, y: 30, s: 55 },
                { x: 820, y: 45, s: 40 }
            ];
            
            debugLog('åˆå§‹åŒ–å®Œæˆ', 'success');
            startListening();
        }
        
        function draw() {
            drawSky();
            drawMountains();
            drawClouds();
            drawRiver();
            drawBanks();
            
            if (animationState !== 'idle') updateKite();
            
            drawKite();
            drawParticles();
            
            if (animationState === 'idle') drawIdleText();
        }
        
        function drawSky() {
            for (let y = 0; y < river.y; y++) {
                let t = y / river.y;
                let c = lerpColor(color(COLORS.skyLight), color(COLORS.lavender), t);
                stroke(c);
                line(0, y, width, y);
            }
        }
        
        function drawMountains() {
            noStroke();
            
            fill(COLORS.mountainFar);
            beginShape();
            vertex(0, river.y); vertex(0, 180);
            vertex(120, 140); vertex(240, 170); vertex(360, 120);
            vertex(480, 155); vertex(600, 110); vertex(720, 145);
            vertex(840, 125); vertex(width, 150); vertex(width, river.y);
            endShape(CLOSE);
            
            fill(COLORS.mountainMid);
            beginShape();
            vertex(0, river.y); vertex(0, 220);
            vertex(160, 190); vertex(280, 215); vertex(400, 175);
            vertex(520, 200); vertex(640, 165); vertex(760, 195);
            vertex(880, 180); vertex(width, 205); vertex(width, river.y);
            endShape(CLOSE);
            
            fill(COLORS.mountainNear);
            beginShape();
            vertex(0, river.y); vertex(0, 270);
            vertex(100, 250); vertex(200, 275); vertex(320, 240);
            vertex(440, 265); vertex(560, 235); vertex(680, 260);
            vertex(800, 245); vertex(900, 270); vertex(width, 255); vertex(width, river.y);
            endShape(CLOSE);
        }
        
        function drawClouds() {
            noStroke();
            fill(255, 255, 255, 200);
            for (let c of clouds) {
                let cx = c.x + sin(frameCount * 0.008 + c.x * 0.01) * 5;
                ellipse(cx, c.y, c.s * 1.6, c.s * 0.7);
                ellipse(cx - c.s * 0.4, c.y + 5, c.s * 0.8, c.s * 0.5);
                ellipse(cx + c.s * 0.5, c.y + 3, c.s, c.s * 0.6);
            }
        }
        
        function drawRiver() {
            river.wave += 0.025;
            for (let y = river.y; y < height; y++) {
                let t = (y - river.y) / (height - river.y);
                let c = lerpColor(color(COLORS.riverMain), color(COLORS.riverDark), t);
                stroke(c);
                line(0, y, width, y);
            }
            
            noFill();
            for (let i = 0; i < 5; i++) {
                stroke(255, 255, 255, 120 - i * 20);
                strokeWeight(2);
                beginShape();
                for (let x = 0; x <= width; x += 20) {
                    let y = river.y + 20 + i * 30 + sin(x * 0.012 + river.wave + i * 0.8) * 6;
                    vertex(x, y);
                }
                endShape();
            }
            strokeWeight(1);
        }
        
        function drawBanks() {
            noStroke();
            
            fill(COLORS.bankSide);
            beginShape();
            vertex(0, river.y - 25); vertex(130, river.y - 25);
            vertex(145, river.y + 10); vertex(0, river.y + 10);
            endShape(CLOSE);
            
            fill(COLORS.bankTop);
            rect(0, river.y - 45, 130, 25, 0, 12, 0, 0);
            
            fill(COLORS.bankSide);
            beginShape();
            vertex(width, river.y - 25); vertex(width - 130, river.y - 25);
            vertex(width - 145, river.y + 10); vertex(width, river.y + 10);
            endShape(CLOSE);
            
            fill(COLORS.bankTop);
            rect(width - 130, river.y - 45, 130, 25, 12, 0, 0, 0);
            
            drawGrass(25, river.y - 45);
            drawGrass(55, river.y - 43);
            drawGrass(90, river.y - 46);
            drawGrass(width - 30, river.y - 45);
            drawGrass(width - 60, river.y - 43);
            drawGrass(width - 95, river.y - 46);
        }
        
        function drawGrass(x, y) {
            stroke(COLORS.deepPurple);
            strokeWeight(2);
            for (let i = -1; i <= 1; i++) {
                let sway = sin(frameCount * 0.04 + x) * 2;
                line(x + i * 5, y, x + i * 5 + sway + i, y - 12 - abs(i) * 3);
            }
            strokeWeight(1);
            noStroke();
        }
        
        function drawKite() {
            push();
            translate(kite.x, kite.y);
            rotate(kite.angle + sin(kite.wobble) * 0.06);
            
            noStroke();
            fill(0, 0, 0, 25);
            beginShape();
            vertex(4, -32); vertex(28, 4); vertex(4, 44); vertex(-20, 4);
            endShape(CLOSE);
            
            fill(COLORS.kiteMain);
            stroke(COLORS.kiteFrame);
            strokeWeight(2);
            beginShape();
            vertex(0, -35); vertex(25, 0); vertex(0, 45); vertex(-25, 0);
            endShape(CLOSE);
            
            noStroke();
            fill(COLORS.kiteAccent);
            beginShape();
            vertex(0, -12); vertex(10, 0); vertex(0, 15); vertex(-10, 0);
            endShape(CLOSE);
            
            stroke(COLORS.kiteFrame);
            strokeWeight(3);
            line(0, -35, 0, 45);
            line(-25, 0, 25, 0);
            
            noStroke();
            fill(COLORS.lavender);
            ellipse(0, 0, 12, 12);
            fill(COLORS.kiteAccent);
            ellipse(0, 0, 6, 6);
            
            pop();
            
            drawTail();
            drawString();
        }
        
        function drawTail() {
            kite.tail.unshift({ x: kite.x, y: kite.y + 45 });
            if (kite.tail.length > 20) kite.tail.pop();
            
            noFill();
            stroke(COLORS.kiteAccent);
            strokeWeight(3);
            
            beginShape();
            for (let i = 0; i < kite.tail.length; i++) {
                let p = kite.tail[i];
                let w = sin(frameCount * 0.08 + i * 0.5) * (6 + i * 0.4);
                curveVertex(p.x + w, p.y + i * 3.5);
            }
            endShape();
            
            for (let i = 4; i < kite.tail.length; i += 5) {
                let p = kite.tail[i];
                let w = sin(frameCount * 0.08 + i * 0.5) * (6 + i * 0.4);
                let bx = p.x + w, by = p.y + i * 3.5;
                
                noStroke();
                fill(COLORS.lavender);
                triangle(bx - 6, by, bx, by - 3, bx, by + 3);
                triangle(bx + 6, by, bx, by - 3, bx, by + 3);
                fill(COLORS.mint);
                ellipse(bx, by, 5, 5);
            }
            
            strokeWeight(1);
        }
        
        function drawString() {
            let hx = 55, hy = river.y - 25;
            
            stroke(COLORS.kiteFrame);
            strokeWeight(1.5);
            noFill();
            beginShape();
            vertex(hx, hy);
            quadraticVertex((hx + kite.x) / 2, (hy + kite.y + 45) / 2 + 35, kite.x, kite.y + 45);
            endShape();
            
            drawPerson(hx, river.y - 45);
        }
        
        function drawPerson(x, y) {
            noStroke();
            fill(COLORS.lavender);
            rect(x - 6, y, 12, 20, 4);
            fill(COLORS.white);
            ellipse(x, y - 4, 14, 14);
            fill(COLORS.kiteAccent);
            arc(x, y - 6, 16, 12, PI, TWO_PI);
            rect(x - 10, y - 6, 20, 3, 1);
            stroke(COLORS.lavender);
            strokeWeight(3);
            line(x + 6, y + 6, x + 15, y - 8);
            strokeWeight(1);
            noStroke();
        }
        
        function addParticle(x, y, type) {
            for (let i = 0; i < 4; i++) {
                particles.push({
                    x: x + random(-25, 25),
                    y: y + random(-25, 25),
                    vx: random(-2.5, 2.5),
                    vy: random(-2.5, 2.5),
                    size: random(6, 14),
                    life: 45,
                    type: type
                });
            }
        }
        
        function drawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                
                if (p.life <= 0) { particles.splice(i, 1); continue; }
                
                let a = map(p.life, 0, 45, 0, 255);
                noStroke();
                
                if (p.type === 'star') {
                    fill(141, 201, 159, a);
                    drawStar(p.x, p.y, p.size / 2, p.size / 4, 4);
                } else if (p.type === 'wind') {
                    fill(255, 255, 255, a);
                    ellipse(p.x, p.y, p.size, p.size / 2);
                } else {
                    fill(168, 219, 181, a);
                    ellipse(p.x, p.y, p.size, p.size * 0.7);
                }
            }
        }
        
        function drawStar(x, y, r1, r2, n) {
            beginShape();
            for (let i = 0; i < n * 2; i++) {
                let r = i % 2 === 0 ? r1 : r2;
                let angle = i * PI / n - PI / 2;
                vertex(x + cos(angle) * r, y + sin(angle) * r);
            }
            endShape(CLOSE);
        }
        
        function drawIdleText() {
            fill(69, 61, 124, 200);
            noStroke();
            rectMode(CENTER);
            rect(width / 2, height / 2, 280, 80, 15);
            rectMode(CORNER);
            
            fill(COLORS.white);
            textAlign(CENTER, CENTER);
            textSize(22);
            textStyle(BOLD);
            text('ç­‰å¾…æ–°è®¾è®¡...', width / 2, height / 2 - 8);
            
            let pulse = sin(frameCount * 0.04) * 0.3 + 0.7;
            fill(141, 201, 159, 255 * pulse);
            textSize(12);
            textStyle(NORMAL);
            text(connectionOk ? 'â— å·²è¿æ¥' : 'â—‹ è¿æ¥ä¸­', width / 2, height / 2 + 20);
        }
        
        function updateKite() {
            animationProgress += deltaTime;
            let p = constrain(animationProgress / CONFIG.ANIMATION_DURATION, 0, 1);
            let ep = easeInOutCubic(p);
            
            if (resultType === 'success') {
                kite.x = lerp(80, 880, ep);
                kite.y = lerp(180, 100, ep) + sin(frameCount * 0.05) * 4;
                kite.angle = sin(frameCount * 0.03) * 0.04;
                kite.wobble += 0.08;
                if (frameCount % 18 === 0) addParticle(kite.x, kite.y, 'star');
            } else if (resultType === 'struggle') {
                kite.x = lerp(80, 880, ep);
                kite.y = lerp(180, 160, ep) + sin(frameCount * 0.1) * 30;
                kite.angle = sin(frameCount * 0.08) * 0.3;
                kite.wobble += 0.2;
                if (frameCount % 6 === 0) addParticle(kite.x, kite.y, 'wind');
            } else {
                if (p < 0.4) {
                    kite.x = lerp(80, 380, p / 0.4);
                    kite.y = lerp(180, 130, p / 0.4) + sin(frameCount * 0.12) * 40;
                    kite.angle = sin(frameCount * 0.1) * 0.4;
                } else {
                    let fp = (p - 0.4) / 0.6;
                    kite.x = lerp(380, 340, fp);
                    kite.y = lerp(130, river.y + 50, fp * fp);
                    kite.angle += 0.06;
                    if (frameCount % 4 === 0) addParticle(kite.x, kite.y, 'splash');
                }
                kite.wobble += 0.25;
            }
            
            if (p >= 1) showResult();
        }
        
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        function startAnimation(score, data) {
            if (isAnimating) return;
            
            isAnimating = true;
            currentScore = score;
            crossingScore = score;
            currentDesignData = data;
            animationProgress = 0;
            
            resultType = score >= CONFIG.SCORE_SUCCESS ? 'success' : score >= CONFIG.SCORE_STRUGGLE ? 'struggle' : 'fail';
            
            kite = { x: 80, y: 180, angle: 0, wobble: 0, tail: [] };
            particles = [];
            
            animationState = 'flying';
            debugLog(`åŠ¨ç”»å¼€å§‹: ${score.toFixed(1)}åˆ†`, 'success');
        }
        
        function showResult() {
            animationState = 'idle';
            isAnimating = false;
            
            // åŠ¨ç”»ç»“æŸåå¯åŠ¨ä¸“å®¶ç‚¹è¯„
            setTimeout(() => {
                startExpertReview();
            }, 500);
        }
        
        // ==================== æµ‹è¯•ä¸æ•°æ® ====================
        function testAnimation(score) {
            const testDesign = {
                materials: {
                    'éª¨æ¶ææ–™': ['ç«¹å­'],
                    'é£ç­é¢æ–™': ['ä¸ç»¸'],
                    'ç»³ç´¢ææ–™': ['éº»ç»³']
                }
            };
            debugLog(`æµ‹è¯• ${score}åˆ†`);
            startAnimation(score, testDesign);
        }
        
        function manualCheck() {
            debugLog('æ‰‹åŠ¨æ£€æŸ¥');
            checkForNewDesigns();
        }
        
        async function fetchDesigns() {
            const jsonbinUrl = `https://api.jsonbin.io/v3/b/${CONFIG.BIN_ID}/latest`;
            
            try {
                debugLog('ç›´æ¥è¯·æ±‚ JSONBin...', 'info');
                
                const res = await fetch(jsonbinUrl, {
                    method: 'GET',
                    headers: {
                        'X-Master-Key': CONFIG.JSONBIN_API_KEY
                    }
                });
                
                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}`);
                }
                
                const data = await res.json();
                
                connectionOk = true;
                document.getElementById('status-connection').textContent = 'âœ“ å·²è¿æ¥';
                document.getElementById('status-connection').className = 'status-item success';
                debugLog('JSONBin è¿æ¥æˆåŠŸ', 'success');
                
                return data.record?.designs || [];
            } catch (e) {
                connectionOk = false;
                document.getElementById('status-connection').textContent = 'âœ— æ–­å¼€';
                document.getElementById('status-connection').className = 'status-item error';
                debugLog(`JSONBin å¤±è´¥: ${e.message}`, 'error');
                return null;
            }
        }
        
        function calcScore(d) {
            const m = d.materials || {};
            const PROPS = {
                'éª¨æ¶ææ–™': { 'ç«¹å­': 70, 'é“åˆé‡‘': 85, 'ç¢³çº¤ç»´': 95 },
                'é£ç­é¢æ–™': { 'ä¸ç»¸': 75, 'å°¼é¾™': 85, 'Mylarè†œ': 80 },
                'ç»³ç´¢ææ–™': { 'éº»ç»³': 65, 'é’¢ç´¢': 80, 'å‡¯å¤«æ‹‰': 95 }
            };
            
            let ps = 0, pc = 0;
            for (let c in m) for (let i of (m[c] || [])) if (PROPS[c]?.[i]) { ps += PROPS[c][i]; pc++; }
            
            let perf = pc > 0 ? ps / pc : 30;
            let fm = m['éª¨æ¶ææ–™']?.length || 0, sm = m['é£ç­é¢æ–™']?.length || 0, rm = m['ç»³ç´¢ææ–™']?.length || 0;
            let complete = fm > 0 && sm > 0 && rm > 0;
            let hasD = (d.drawing?.object_count || 0) > 0;
            let feas = complete && hasD ? 100 : complete ? 80 : (fm || sm) && hasD ? 60 : (fm || sm) ? 50 : 30;
            
            const costMap = { 'ç«¹å­': 10, 'é“åˆé‡‘': 35, 'ç¢³çº¤ç»´': 80, 'ä¸ç»¸': 20, 'å°¼é¾™': 15, 'Mylarè†œ': 30, 'éº»ç»³': 5, 'é’¢ç´¢': 20, 'å‡¯å¤«æ‹‰': 50 };
            let cost = 0;
            for (let c in m) for (let i of (m[c] || [])) cost += costMap[i] || 0;
            let costS = cost < 50 ? 100 : cost < 100 ? 80 : cost < 150 ? 60 : 30;
            
            let inno = Math.min((fm + sm + rm) * 20, 100);
            
            return Math.round((perf * 0.4 + feas * 0.3 + costS * 0.2 + inno * 0.1) * 10) / 10;
        }
        
        async function checkForNewDesigns() {
            if (isAnimating) return;
            document.getElementById('status-time').textContent = new Date().toLocaleTimeString();
            
            const designs = await fetchDesigns();
            if (!designs) {
                debugLog('è·å–è®¾è®¡å¤±è´¥', 'error');
                return;
            }
            
            debugLog(`è·å–åˆ° ${designs.length} ä¸ªè®¾è®¡ï¼Œå·²å¤„ç† ${processedDesigns.size} ä¸ª`, 'info');
            
            for (let d of designs) {
                const id = d.design_id || d.created_at;
                debugLog(`æ£€æŸ¥è®¾è®¡: ${id}`, 'info');
                if (!processedDesigns.has(id)) {
                    debugLog(`å‘ç°æ–°è®¾è®¡: ${id}`, 'success');
                    processedDesigns.add(id);
                    evaluatedCount++;
                    document.getElementById('status-count').textContent = `å·²è¯„ä¼°: ${evaluatedCount}`;
                    startAnimation(calcScore(d), d);
                    break;
                }
            }
        }
        
        function startListening() {
            debugLog('å¼€å§‹ç›‘å¬');
            fetchDesigns().then(ds => {
                if (ds) {
                    ds.forEach(d => processedDesigns.add(d.design_id || d.created_at));
                    debugLog(`æ ‡è®° ${processedDesigns.size} ä¸ª`, 'success');
                }
            });
            setInterval(checkForNewDesigns, CONFIG.CHECK_INTERVAL);
        }
    </script>
</body>
</html>
